# Штаб гражданской обороны Тридесятой области решил обновить план спасения на случай ядерной атаки.
# Известно, что все n селений Тридесятой области находятся вдоль одной прямой дороги.
# Вдоль дороги также расположены m бомбоубежищ, в которых жители селений могут укрыться на случай ядерной атаки.
#
# Чтобы спасение в случае ядерной тревоги проходило как можно эффективнее,
# необходимо для каждого селения определить ближайшее к нему бомбоубежище.
#
# Формат ввода
#
# В первой строке вводится число n - количество селений (1 <= n <= 100000).
# Вторая строка содержит n различных целых чисел,
# i-е из этих чисел задает расстояние от начала дороги до i-го селения.
# В третьей строке входных данных задается число m - количество бомбоубежищ (1 <= m <= 100000).
# Четвертая строка содержит m различных целых чисел,
# i-е из этих чисел задает расстояние от начала дороги до i-го бомбоубежища.
# Все расстояния положительны и не превышают 10⁹.
# Селение и убежище могут располагаться в одной точке.
#
# Формат вывода
#
# Выведите  n чисел - для каждого селения выведите номер ближайшего к нему бомбоубежища.
# Бомбоубежища пронумерованы от 1 до m в том порядке, в котором они заданы во входных данных.
#
# Указание
#
# Создайте список кортежей из пар (позиция селения, его номер в исходном списке),
# а также аналогичный список для бомбоубежищ. Отсортируйте эти списки.
#
# Перебирайте селения в порядке возрастания.
#
# Для селения ближайшими могут быть два соседних бомбоубежища, среди них надо выбрать ближайшее.
# При переходе к следующему селению не обязательно искать ближайшее бомбоубежище с самого начала.
# Его можно искать начиная с позиции, найденной для предыдущего города.
# Аналогично, не нужно искать подходящее бомбоубежище до конца списка бомбоубежищ:
# достаточно найти самое близкое. Если Вы неэффективно реализуете эту часть, то решение тесты не пройдет.
#
# Для хранения ответа используйте список, где индекс будет номером селения,
# а по этому индексу будет запоминаться номер бомбоубежища.


def AppRange(Length, List):
    NewList = []
    for i in range(Length):
        NewList.append((i, List[i]))
    return sorted(NewList)


def Sorted(Range):
    return Range[1]


n = int(input())
country_list = list(map(int, input().split()))
m = int(input())
bomb_list = list(map(int, input().split()))
a1 = AppRange(n, country_list)
b1 = AppRange(m, bomb_list)
a1.sort(key=Sorted)
b1.sort(key=Sorted)
way = [0] * len(a1)
s = b = 0
while s < len(a1):
    if b == len(b1) - 1:
        way[a1[s][0]] = b1[b][0] + 1
        s += 1
    elif abs(a1[s][1] - b1[b][1]) < abs(a1[s][1] - b1[b + 1][1]):
        way[a1[s][0]] = b1[b][0] + 1
        s += 1
    else:
        b += 1
print(*way)
